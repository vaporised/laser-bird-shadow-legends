!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("PhaserRaycaster",[],e):"object"==typeof exports?exports.PhaserRaycaster=e():t.PhaserRaycaster=e()}(window,(function(){return function(t){var e={};function i(n){if(e[n])return e[n].exports;var s=e[n]={i:n,l:!1,exports:{}};return t[n].call(s.exports,s,s.exports,i),s.l=!0,s.exports}return i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var s in t)i.d(n,s,function(e){return t[e]}.bind(null,s));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=4)}([function(t,e,i){"use strict";function n(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Phaser.Math.MAX_SAFE_INTEGER;return this.rayRange=t,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.detectionRange=t,this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}function r(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Phaser.Math.MAX_SAFE_INTEGER;return this.collisionRange=t,this.body&&(this.arcadePhysicsCircle.setRadius(this.collisionRange),this.body.setCircle(this.collisionRange)),this}function o(t){var e,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return!this.detectionRange||(e=i||t.getBounds(),!!Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle,e))}i.r(e),i.d(e,"setRayRange",(function(){return n})),i.d(e,"setDetectionRange",(function(){return s})),i.d(e,"setCollisionRange",(function(){return r})),i.d(e,"boundsInRange",(function(){return o}))},function(t,e,i){"use strict";function n(t){var e=[],i=!1,n=new Phaser.Geom.Circle(this.origin.x,this.origin.y,this.collisionRange);if(void 0===t?(t=this._raycaster.scene.physics.overlapCirc(this.origin.x,this.origin.y,this.collisionRange,!0,!0),i=!0):Array.isArray(t)||(t=[t]),i){var s=!0,r=!1,o=void 0;try{for(var a,h=t[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value;if(c!==this.body){var l=void 0;l=c.isCircle?new Phaser.Geom.Circle(c.position.x+c.halfWidth,c.position.y+c.halfWidth,c.halfWidth):new Phaser.Geom.Rectangle(c.x,c.y,c.width,c.height),this.testOverlap(l)&&e.push(c.gameObject)}}}catch(t){r=!0,o=t}finally{try{s||null==h.return||h.return()}finally{if(r)throw o}}}else{var u=!0,g=!1,y=void 0;try{for(var d,f=t[Symbol.iterator]();!(u=(d=f.next()).done);u=!0){var v=d.value;if(void 0!==v.body){var b=void 0;if(v.body.isCircle){if(b=new Phaser.Geom.Circle(v.body.position.x+v.body.halfWidth,v.body.position.y+v.body.halfWidth,v.body.halfWidth),!Phaser.Geom.Intersects.CircleToCircle(n,b))continue}else if(b=new Phaser.Geom.Rectangle(v.body.x,v.body.y,v.body.width,v.body.height),!Phaser.Geom.Intersects.CircleToRectangle(n,b))continue;this.testOverlap(b)&&e.push(v)}}}catch(t){g=!0,y=t}finally{try{u||null==f.return||f.return()}finally{if(g)throw y}}}return e}function s(t,e){var i;if(t._ray===this)i=e;else{if(e._ray!==this)return!1;i=obj1}return this.overlap(i).length>0}function r(t){var e=!0,i=!1,n=void 0;try{for(var s,r=this.slicedIntersections[Symbol.iterator]();!(e=(s=r.next()).done);e=!0){var o=s.value;if(0==t.type?Phaser.Geom.Intersects.TriangleToCircle(o,t):Phaser.Geom.Intersects.RectangleToTriangle(t,o))return!0}}catch(t){i=!0,n=t}finally{try{e||null==r.return||r.return()}finally{if(i)throw n}}return!1}i.r(e),i.d(e,"overlap",(function(){return n})),i.d(e,"processOverlap",(function(){return s})),i.d(e,"testOverlap",(function(){return r}))},function(t,e,i){"use strict";function n(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.angle=Phaser.Math.Angle.Normalize(t),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.angle=Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(t)),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this}i.r(e),i.d(e,"setAngle",(function(){return n})),i.d(e,"setAngleDeg",(function(){return s}))},function(t,e,i){"use strict";function n(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.cone=t,this}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.cone=Phaser.Math.DegToRad(t),this}i.r(e),i.d(e,"setCone",(function(){return n})),i.d(e,"setConeDeg",(function(){return s}))},function(t,e,i){var n=function(t){this.scene=t,this.systems=t.sys,t.sys.settings.isBooted||t.sys.events.once("boot",this.boot,this)};n.register=function(t){t.register("PhaserRaycaster",n,"base")},(n.prototype={boot:function(){var t=this.systems.events;t.on("start",this.start,this),t.on("preupdate",this.preUpdate,this),t.on("update",this.update,this),t.on("postupdate",this.postUpdate,this),t.on("pause",this.pause,this),t.on("resume",this.resume,this),t.on("sleep",this.sleep,this),t.on("wake",this.wake,this),t.on("shutdown",this.shutdown,this),t.on("destroy",this.destroy,this)},test:function(t){console.log("RaycasterPlugin says hello "+t+"!")},start:function(){},preUpdate:function(t,e){},update:function(t,e){},postUpdate:function(t,e){},pause:function(){},resume:function(){},sleep:function(){},wake:function(){},shutdown:function(){},destroy:function(){this.shutdown(),this.scene=void 0},createRaycaster:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.scene=this.scene,new this._Raycaster(t)}}).constructor=n,n.prototype._Raycaster=i(5).Raycaster,t.exports=n},function(t,e,i){"use strict";
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
function n(t){return this.version="0.8.0",this.scene,this.graphics,this.boundingBox=!1,this.mappedObjects=[],this.sortedPoints=[],this.mapSegmentCount=0,void 0!==t?(void 0===t.boundingBox&&void 0!==t.scene&&void 0!==t.scene.physics&&(t.boundingBox=t.scene.physics.world.bounds),this.setOptions(t),(void 0===t.autoUpdate||t.autoUpdate)&&this.scene.events.on("update",this.update.bind(this))):this.scene.events.on("update",this.update.bind(this)),this}i.r(e),i.d(e,"Raycaster",(function(){return n})),n.prototype={setOptions:function(t){return void 0!==t.scene&&(this.scene=t.scene,this.graphics=this.scene.add.graphics({lineStyle:{width:1,color:65280},fillStyle:{color:16711935}})),void 0!==t.mapSegmentCount&&(this.mapSegmentCount=t.mapSegmentCount),void 0!==t.objects&&this.mapGameObjects(t.objects),void 0!==t.boundingBox&&this.setBoundingBox(t.boundingBox.x,t.boundingBox.y,t.boundingBox.width,t.boundingBox.height),this},setBoundingBox:function(t,e,i,n){this.boundingBox={rectangle:new Phaser.Geom.Rectangle(t,e,i,n),points:[],segments:[]};var s=[new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.top),new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.top),new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.bottom),new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.bottom)];this.boundingBox.points=s;for(var r=0,o=this.boundingBox.points.length;r<o;r++)r+1<o?this.boundingBox.segments.push(new Phaser.Geom.Line(s[r].x,s[r].y,s[r+1].x,s[r+1].y)):this.boundingBox.segments.push(new Phaser.Geom.Line(s[r].x,s[r].y,s[0].x,s[0].y))},mapGameObjects:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(i.dynamic=e,i.segmentCount=void 0!==i.segmentCount?i.segmentCount:this.segmentCount,!Array.isArray(t)){if(this.mappedObjects.includes(t))return this;t.data||t.setDataEnabled(),i.object=t;var n=new this.Map(i);return t.data.set("raycasterMap",n),this.mappedObjects.push(t),this}var s=!0,r=!1,o=void 0;try{for(var a,h=t[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value;if(!this.mappedObjects.includes(c)){c.data||c.setDataEnabled();var l={};for(var u in i)l[u]=i[u];l.object=c;var g=new this.Map(l);c.data.set("raycasterMap",g),this.mappedObjects.push(c)}}}catch(t){r=!0,o=t}finally{try{s||null==h.return||h.return()}finally{if(r)throw o}}return this},removeMappedObjects:function(t){if(!Array.isArray(t)){var e=this.mappedObjects.indexOf(t);return e>=0&&this.mappedObjects.splice(e,1),this}var i=!0,n=!1,s=void 0;try{for(var r,o=t[Symbol.iterator]();!(i=(r=o.next()).done);i=!0){var a=r.value,h=this.mappedObjects.indexOf(a);h>=0&&this.mappedObjects.splice(h,1)}}catch(t){n=!0,s=t}finally{try{i||null==o.return||o.return()}finally{if(n)throw s}}return this},enableMaps:function(t){if(!Array.isArray(t)){if(t.data){var e=t.data.get("raycasterMap");e&&(e.active=!0)}return this}var i=!0,n=!1,s=void 0;try{for(var r,o=t[Symbol.iterator]();!(i=(r=o.next()).done);i=!0){var a=r.value;if(a.data){var h=a.data.get("raycasterMap");h&&(h.active=!0)}}}catch(t){n=!0,s=t}finally{try{i||null==o.return||o.return()}finally{if(n)throw s}}return this},disableMaps:function(t){if(!Array.isArray(t)){if(t.data){var e=t.data.get("raycasterMap");e&&(e.active=!1)}return this}var i=!0,n=!1,s=void 0;try{for(var r,o=t[Symbol.iterator]();!(i=(r=o.next()).done);i=!0){var a=r.value;if(a.data){var h=a.data.get("raycasterMap");h&&(h.active=!1)}}}catch(t){n=!0,s=t}finally{try{i||null==o.return||o.return()}finally{if(n)throw s}}return this},update:function(){if(this.mappedObjects.length>0){var t=!0,e=!1,i=void 0;try{for(var n,s=this.mappedObjects[Symbol.iterator]();!(t=(n=s.next()).done);t=!0){var r=n.value;if(void 0!==r.data){var o=r.data.get("raycasterMap");o.dynamic&&o.updateMap()}}}catch(t){e=!0,i=t}finally{try{t||null==s.return||s.return()}finally{if(e)throw i}}}},createRay:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new this.Ray(t,this)}},n.prototype.Map=i(6).Map,n.prototype.Ray=i(15).Ray},function(t,e,i){"use strict";function n(t){return this.type,this.active,this.dynamic,this.object,this._points=[],this._segments=[],this.getPoints,this.getSegments,this.updateMap,this.getIntersections,this.config(t),this.updateMap(),this}i.r(e),i.d(e,"Map",(function(){return n})),n.prototype={config:i(7).config},n.prototype.constructor=n},function(t,e,i){"use strict";i.r(e),i.d(e,"config",(function(){return l}));var n=i(8),s=i(9),r=i(10),o=i(11),a=i(12),h=i(13),c=i(14);function l(t){switch(this.object=t.object,void 0===t.type&&(t.type=t.object.type),this.type=t.type,t.type){case"Polygon":this.getPoints=r.getPoints,this.getSegments=r.getSegments,this.updateMap=r.updateMap;break;case"Arc":this.segmentCount=t.segmentCount?t.segmentCount:0,this.getPoints=o.getPoints,this.getSegments=o.getSegments,this.updateMap=o.updateMap,this.setSegmentCount=a.setSegmentCount;break;case"Line":this.getPoints=s.getPoints,this.getSegments=s.getSegments,this.updateMap=s.updateMap;break;case"Container":this.getPoints=h.getPoints,this.getSegments=h.getSegments,this.updateMap=h.updateMap;break;case"StaticTilemapLayer":case"DynamicTilemapLayer":this.collisionTiles=t.collisionTiles?t.collisionTiles:[],this.getPoints=c.getPoints,this.getSegments=c.getSegments,this.updateMap=c.updateMap,this.setCollisionTiles=c.setCollisionTiles,this.object.setOrigin(0,0);break;default:this.getPoints=n.getPoints,this.getSegments=n.getSegments,this.updateMap=n.updateMap}return this.dynamic=1==t.dynamic,this.active=void 0===t.active||t.active,this}},function(t,e,i){"use strict";function n(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this.active?this._points:[]}function s(){return this.active?this._segments:[]}function r(){if(!this.active)return this;for(var t,e=[],i=0,n=(t=[this.object.getTopLeft(),this.object.getTopRight(),this.object.getBottomRight(),this.object.getBottomLeft()]).length;i<n;i++)i+1<n?e.push(new Phaser.Geom.Line(t[i].x,t[i].y,t[i+1].x,t[i+1].y)):e.push(new Phaser.Geom.Line(t[i].x,t[i].y,t[0].x,t[0].y));return this._points=t,this._segments=e,this}i.r(e),i.d(e,"getPoints",(function(){return n})),i.d(e,"getSegments",(function(){return s})),i.d(e,"updateMap",(function(){return r}))},function(t,e,i){"use strict";function n(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this.active?this._points:[]}function s(){return this.active?this._segments:[]}function r(){if(!this.active)return this;var t=[],e=[],i=new Phaser.Geom.Point;i.x=this.object.x-this.object.displayWidth*this.object.originX,i.y=this.object.y-this.object.displayHeight*this.object.originY;var n=this.object.geom.getPointA(),s=this.object.geom.getPointB(),r=this.object.rotation;if(0!==r){var o=new Phaser.Geom.Line(this.object.x,this.object.y,n.x*this.object.scaleX+i.x,n.y*this.object.scaleY+i.y);Phaser.Geom.Line.SetToAngle(o,this.object.x,this.object.y,Phaser.Geom.Line.Angle(o)+r,Phaser.Geom.Line.Length(o)),n=o.getPointB();var a=new Phaser.Geom.Line(this.object.x,this.object.y,s.x*this.object.scaleX+i.x,s.y*this.object.scaleY+i.y);Phaser.Geom.Line.SetToAngle(a,this.object.x,this.object.y,Phaser.Geom.Line.Angle(a)+r,Phaser.Geom.Line.Length(a)),s=a.getPointB(),t.push(new Phaser.Geom.Point(n.x,n.y)),t.push(new Phaser.Geom.Point(s.x,s.y)),e.push(new Phaser.Geom.Line(n.x,n.y,s.x,s.y))}else t.push(new Phaser.Geom.Point(n.x*this.object.scaleX+i.x,n.y*this.object.scaleY+i.y)),t.push(new Phaser.Geom.Point(s.x*this.object.scaleX+i.x,s.y*this.object.scaleY+i.y)),e.push(new Phaser.Geom.Line(n.x*this.object.scaleX+i.x,n.y*this.object.scaleY+i.y,s.x+i.x*this.object.scaleX,s.y*this.object.scaleY+i.y));return this._points=t,this._segments=e,this}i.r(e),i.d(e,"getPoints",(function(){return n})),i.d(e,"getSegments",(function(){return s})),i.d(e,"updateMap",(function(){return r}))},function(t,e,i){"use strict";function n(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this.active?this._points:[]}function s(){return this.active?this._segments:[]}function r(){if(!this.active)return this;var t=[],e=[],i=new Phaser.Geom.Point;i.x=this.object.x-this.object.displayWidth*this.object.originX,i.y=this.object.y-this.object.displayHeight*this.object.originY;var n=this.object.rotation;if(0!==n){var s=!0,r=!1,o=void 0;try{for(var a,h=this.object.geom.points[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value,l=new Phaser.Geom.Line(this.object.x,this.object.y,c.x*this.object.scaleX+i.x,c.y*this.object.scaleY+i.y);Phaser.Geom.Line.SetToAngle(l,this.object.x,this.object.y,Phaser.Geom.Line.Angle(l)+n,Phaser.Geom.Line.Length(l)),t.push(l.getPointB())}}catch(t){r=!0,o=t}finally{try{s||null==h.return||h.return()}finally{if(r)throw o}}}else{var u=!0,g=!1,y=void 0;try{for(var d,f=this.object.geom.points[Symbol.iterator]();!(u=(d=f.next()).done);u=!0){var v=d.value;t.push(new Phaser.Geom.Point(v.x*this.object.scaleX+i.x,v.y*this.object.scaleY+i.y))}}catch(t){g=!0,y=t}finally{try{u||null==f.return||f.return()}finally{if(g)throw y}}}for(var b=0,p=t.length;b<p;b++)b+1<p&&e.push(new Phaser.Geom.Line(t[b].x,t[b].y,t[b+1].x,t[b+1].y));if(this.object.closePath){var P=t.length-1;e.push(new Phaser.Geom.Line(t[P].x,t[P].y,t[0].x,t[0].y))}return this._points=t,this._segments=e,this}i.r(e),i.d(e,"getPoints",(function(){return n})),i.d(e,"getSegments",(function(){return s})),i.d(e,"updateMap",(function(){return r}))},function(t,e,i){"use strict";function n(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this.active)return[];if(this._points.length>0)return this._points;var e=[],i=new Phaser.Geom.Point;if(i.x=this.object.x-this.object.displayWidth*(this.object.originX-.5),i.y=this.object.y-this.object.displayHeight*(this.object.originY-.5),t){var n,s=new Phaser.Geom.Line,r=new Phaser.Geom.Line,o=this.object.rotation;if(0!==o){var a=new Phaser.Geom.Line(this.object.x,this.object.y,i.x,i.y);Phaser.Geom.Line.SetToAngle(a,this.object.x,this.object.y,Phaser.Geom.Line.Angle(a)+o,Phaser.Geom.Line.Length(a));var h=a.getPointB();n=new Phaser.Geom.Line(t.origin.x,t.origin.y,h.x,h.y)}else n=new Phaser.Geom.Line(t.origin.x,t.origin.y,i.x,i.y);var c=Math.sqrt(Math.pow(Phaser.Geom.Line.Length(n),2)-Math.pow(this.object.radius*this.object.scaleX,2)),l=Phaser.Geom.Line.Angle(n),u=Math.asin(this.object.radius*this.object.scaleX/Phaser.Geom.Line.Length(n));Phaser.Geom.Line.SetToAngle(s,t.origin.x,t.origin.y,l-u,c),Phaser.Geom.Line.SetToAngle(r,t.origin.x,t.origin.y,l+u,c),e.push(s.getPointB()),e.push(r.getPointB())}return e}function s(){return this.active?this._segments:[]}function r(){if(!this.active)return this;if(!this.segmentCount)return this._points=[],this._segments=[],this;var t=new Phaser.Geom.Point;t.x=this.object.x-this.object.displayWidth*this.object.originX+this.object.radius*this.object.scaleX,t.y=this.object.y-this.object.displayHeight*this.object.originY+this.object.radius*this.object.scaleY;var e=this.object.geom.getPoints(this.segmentCount),i=[],n=this.object.rotation;if(0!==n){var s=[],r=!0,o=!1,a=void 0;try{for(var h,c=e[Symbol.iterator]();!(r=(h=c.next()).done);r=!0){var l=h.value,u=new Phaser.Geom.Line(this.object.x,this.object.y,this.object.x+(l.x+this.object.radius)*this.object.scaleX,this.object.y+(l.y+this.object.radius)*this.object.scaleY);Phaser.Geom.Line.SetToAngle(u,this.object.x,this.object.y,Phaser.Geom.Line.Angle(u)+n,Phaser.Geom.Line.Length(u)),s.push(u.getPointB())}}catch(t){o=!0,a=t}finally{try{r||null==c.return||c.return()}finally{if(o)throw a}}e=s}else{var g=!0,y=!1,d=void 0;try{for(var f,v=e[Symbol.iterator]();!(g=(f=v.next()).done);g=!0){var b=f.value;b.x=b.x*this.object.scaleX+t.x,b.y=b.y*this.object.scaleY+t.y}}catch(t){y=!0,d=t}finally{try{g||null==v.return||v.return()}finally{if(y)throw d}}}for(var p=0,P=e.length;p<P;p++)p+1<P?i.push(new Phaser.Geom.Line(e[p].x,e[p].y,e[p+1].x,e[p+1].y)):i.push(new Phaser.Geom.Line(e[p].x,e[p].y,e[0].x,e[0].y));return this._points=e,this._segments=i,this}i.r(e),i.d(e,"getPoints",(function(){return n})),i.d(e,"getSegments",(function(){return s})),i.d(e,"updateMap",(function(){return r}))},function(t,e,i){"use strict";function n(t){return this.segmentCount=t,this.updateMap(),this}i.r(e),i.d(e,"setSegmentCount",(function(){return n}))},function(t,e,i){"use strict";function n(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.active)return[];var i=[];e||(i=this._points);var n=new Phaser.Geom.Point;if(n.x=this.object.x-this.object.displayWidth*this.object.originX,n.y=this.object.y-this.object.displayHeight*this.object.originY,t){var s=new Phaser.Geom.Line(0,0,t.origin.x-n.x,t.origin.y-n.y);Phaser.Geom.Line.SetToAngle(s,0,0,Phaser.Geom.Line.Angle(s)-this.object.rotation,Phaser.Geom.Line.Length(s));var r=t._raycaster.createRay({origin:{x:s.getPointB().x,y:s.getPointB().y}}),o=!0,a=!1,h=void 0;try{for(var c,l=this.object.list[Symbol.iterator]();!(o=(c=l.next()).done);o=!0){var u=c.value;if("Arc"===u.type){var g=u.data.get("raycasterMap");if(0==g._points.length){var y=!0,d=!1,f=void 0;try{for(var v,b=g.getPoints(r,!0)[Symbol.iterator]();!(y=(v=b.next()).done);y=!0){var p=v.value,P=new Phaser.Geom.Line(0,0,p.x,p.y);Phaser.Geom.Line.SetToAngle(P,0,0,Phaser.Geom.Line.Angle(P)+this.object.rotation,Phaser.Geom.Line.Length(P)),i.push(new Phaser.Geom.Point(P.getPointB().x+n.x,P.getPointB().y+n.y))}}catch(t){d=!0,f=t}finally{try{y||null==b.return||b.return()}finally{if(d)throw f}}}}else if("Container"===u.type){var m=!0,x=!1,j=void 0;try{for(var w,G=u.data.get("raycasterMap").getPoints(r,!0)[Symbol.iterator]();!(m=(w=G.next()).done);m=!0){var R=w.value;if(0!==this.object.rotation){var L=new Phaser.Geom.Line(this.object.x,this.object.y,R.x*this.object.scaleX+n.x,R.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(L,this.object.x,this.object.y,Phaser.Geom.Line.Angle(L)+this.object.rotation,Phaser.Geom.Line.Length(L)),i.push(L.getPointB())}else i.push(new Phaser.Geom.Point(R.x*this.object.scaleX+n.x,R.y*this.object.scaleX+n.y))}}catch(t){x=!0,j=t}finally{try{m||null==G.return||G.return()}finally{if(x)throw j}}}}}catch(t){a=!0,h=t}finally{try{o||null==l.return||l.return()}finally{if(a)throw h}}}return i}function s(){return this.active?this._segments:[]}function r(){if(!this.active)return this;var t=[],e=[],i=this.object,n=new Phaser.Geom.Point;n.x=this.object.x-this.object.displayWidth*this.object.originX,n.y=this.object.y-this.object.displayHeight*this.object.originY;var s=i.rotation;i.iterate(function(r){r.data||r.setDataEnabled();var o=r.data.get("raycasterMap");o?o.updateMap():(o=new this.constructor({object:r,segmentCount:this.segmentCount}),r.data.set("raycasterMap",o));var a=[],h=!0,c=!1,l=void 0;try{for(var u,g=o.getPoints()[Symbol.iterator]();!(h=(u=g.next()).done);h=!0){var y=u.value;if(0!==s){var d=new Phaser.Geom.Line(this.object.x,this.object.y,y.x*this.object.scaleX+n.x,y.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(d,this.object.x,this.object.y,Phaser.Geom.Line.Angle(d)+s,Phaser.Geom.Line.Length(d)),t.push(d.getPointB())}else t.push(new Phaser.Geom.Point(y.x*i.scaleX+n.x,y.y*i.scaleX+n.y));a.push(t[t.length-1])}}catch(t){c=!0,l=t}finally{try{h||null==g.return||g.return()}finally{if(c)throw l}}var f=!0,v=!1,b=void 0;try{for(var p,P=o.getSegments()[Symbol.iterator]();!(f=(p=P.next()).done);f=!0){var m=p.value;if(0!==s){var x=m.getPointA(),j=m.getPointB(),w=new Phaser.Geom.Line(this.object.x,this.object.y,x.x*this.object.scaleX+n.x,x.y*this.object.scaleY+n.y),G=new Phaser.Geom.Line(this.object.x,this.object.y,j.x*this.object.scaleX+n.x,j.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(w,this.object.x,this.object.y,Phaser.Geom.Line.Angle(w)+s,Phaser.Geom.Line.Length(w)),Phaser.Geom.Line.SetToAngle(G,this.object.x,this.object.y,Phaser.Geom.Line.Angle(G)+s,Phaser.Geom.Line.Length(G)),e.push(new Phaser.Geom.Line(w.getPointB().x,w.getPointB().y,G.getPointB().x,G.getPointB().y))}else e.push(new Phaser.Geom.Line(m.getPointA().x*i.scaleX+n.x,m.getPointA().y*i.scaleY+n.y,m.getPointB().x*i.scaleX+n.x,m.getPointB().y*i.scaleY+n.y))}}catch(t){v=!0,b=t}finally{try{f||null==P.return||P.return()}finally{if(v)throw b}}}.bind(this));for(var r=0,o=i.list.length;r<o;r++)for(var a=i.list[r],h=a.data.get("raycasterMap"),c=r+1,l=i.list.length;c<l;c++){var u=i.list[c],g=u.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(a.getBounds(),u.getBounds())){var y=!0,d=!1,f=void 0;try{for(var v,b=h.getSegments()[Symbol.iterator]();!(y=(v=b.next()).done);y=!0){var p=v.value,P=!0,m=!1,x=void 0;try{for(var j,w=g.getSegments()[Symbol.iterator]();!(P=(j=w.next()).done);P=!0){var G=j.value,R=[];if(Phaser.Geom.Intersects.LineToLine(p,G,R))if(0!==s){var L=new Phaser.Geom.Line(this.object.x,this.object.y,R.x*this.object.scaleX+n.x,R.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(L,this.object.x,this.object.y,Phaser.Geom.Line.Angle(L)+s,Phaser.Geom.Line.Length(L)),t.push(L.getPointB())}else t.push(new Phaser.Geom.Point(R.x*i.scaleX+n.x,R.y*i.scaleX+n.y))}}catch(t){m=!0,x=t}finally{try{P||null==w.return||w.return()}finally{if(m)throw x}}}}catch(t){d=!0,f=t}finally{try{y||null==b.return||b.return()}finally{if(d)throw f}}}}return this._points=t,this._segments=e,this}i.r(e),i.d(e,"getPoints",(function(){return n})),i.d(e,"getSegments",(function(){return s})),i.d(e,"updateMap",(function(){return r}))},function(t,e,i){"use strict";function n(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this.active)return[];if(!t||t&&(0==t.detectionRange||t.detectionRange>=Phaser.Math.MAX_SAFE_INTEGER))return this._points;var e=[],i=!0,n=!1,s=void 0;try{for(var r,o=this._points[Symbol.iterator]();!(i=(r=o.next()).done);i=!0){var a=r.value;Phaser.Math.Distance.Between(t.origin.x,t.origin.y,a.x,a.y)<=t.detectionRange&&e.push(a)}}catch(t){n=!0,s=t}finally{try{i||null==o.return||o.return()}finally{if(n)throw s}}var h=this.getSegments(t),c=!0,l=!1,u=void 0;try{for(var g,y=h[Symbol.iterator]();!(c=(g=y.next()).done);c=!0){var d=g.value;Phaser.Math.Distance.Between(t.origin.x,t.origin.y,d.x1,d.y1)>t.detectionRange&&e.push(new Phaser.Geom.Point(d.x1,d.y1)),Phaser.Math.Distance.Between(t.origin.x,t.origin.y,d.x2,d.y2)>t.detectionRange&&e.push(new Phaser.Geom.Point(d.x2,d.y2))}}catch(t){l=!0,u=t}finally{try{c||null==y.return||y.return()}finally{if(l)throw u}}return e}function s(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this.active)return[];if(!t||t&&(0==t.detectionRange||t.detectionRange>=Phaser.Math.MAX_SAFE_INTEGER))return this._segments;var e=[],i=!0,n=!1,s=void 0;try{for(var r,o=this._segments[Symbol.iterator]();!(i=(r=o.next()).done);i=!0){var a=r.value;Phaser.Geom.Intersects.LineToCircle(a,t.detectionRangeCircle)&&e.push(a)}}catch(t){n=!0,s=t}finally{try{i||null==o.return||o.return()}finally{if(n)throw s}}return e}function r(){var t=this;if(!this.active)return this;var e=[],i=[],n=new Phaser.Geom.Point;n.x=this.object.x,n.y=this.object.y;for(var s=!1,r=[],o=[],a=0,h=this.object.layer.data.length;a<h;a++){for(var c=this.object.layer.data[a],l=0,u=c.length;l<u;l++){var g=c[l],d=!!(a>0&&this.collisionTiles.includes(this.object.layer.data[a-1][l].index)!=this.collisionTiles.includes(g.index)||0==a&&this.collisionTiles.includes(g.index)),f=!!(l>0&&this.collisionTiles.includes(this.object.layer.data[a][l-1].index)!=this.collisionTiles.includes(g.index)||0==l&&this.collisionTiles.includes(g.index)),v=!1;if(o.length<=l?o[l]=[]:o[l].length>0&&(v=o[l][o[l].length-1]),f&&(v&&v.y+v.height==a?v.height++:o[l].push({x:g.x,y:g.y,height:1})),d)s?s.width++:s={x:g.x,y:g.y,width:1};else if(s){var b=s.x*this.object.layer.tileWidth*this.object.scaleX+n.x,p=s.y*this.object.layer.tileHeight*this.object.scaleY+n.y,P=new Phaser.Geom.Line(b,p,b+this.object.layer.tileWidth*this.object.scaleX*s.width,p);i.push(P),r.push(P),e.push(new Phaser.Geom.Point(b,p)),e.push(new Phaser.Geom.Point(b+this.object.layer.tileWidth*this.object.scaleX*s.width,p)),s=!1}}if(s){var m=s.x*this.object.layer.tileWidth*this.object.scaleX+n.x,x=s.y*this.object.layer.tileHeight*this.object.scaleY+n.y,j=new Phaser.Geom.Line(m,x,m+this.object.layer.tileWidth*this.object.scaleX*s.width,x);i.push(j),r.push(j),e.push(new Phaser.Geom.Point(m,x)),e.push(new Phaser.Geom.Point(m+this.object.layer.tileWidth*this.object.scaleX*s.width,x)),s=!1}}var w=!0,G=!1,R=void 0;try{for(var L,S=this.object.layer.data[this.object.layer.data.length-1][Symbol.iterator]();!(w=(L=S.next()).done);w=!0){var M=L.value;if(this.collisionTiles.includes(M.index))s?s.width++:s={x:M.x,y:M.y+1,width:1};else if(s){var A=s.x*this.object.layer.tileWidth*this.object.scaleX+n.x,_=s.y*this.object.layer.tileHeight*this.object.scaleY+n.y,T=new Phaser.Geom.Line(A,_,A+this.object.layer.tileWidth*this.object.scaleX*s.width,_);i.push(T),r.push(T),e.push(new Phaser.Geom.Point(A,_)),e.push(new Phaser.Geom.Point(A+this.object.layer.tileWidth*this.object.scaleX*s.width,_)),s=!1}}}catch(t){G=!0,R=t}finally{try{w||null==S.return||S.return()}finally{if(G)throw R}}if(s){var B=s.x*this.object.layer.tileWidth*this.object.scaleX+n.x,C=s.y*this.object.layer.tileHeight*this.object.scaleY+n.y,D=new Phaser.Geom.Line(B,C,B+this.object.layer.tileWidth*this.object.scaleX*s.width,C);i.push(D),r.push(D),e.push(new Phaser.Geom.Point(B,C)),e.push(new Phaser.Geom.Point(B+this.object.layer.tileWidth*this.object.scaleX*s.width,C)),s=!1}var X=!1,O=[],I=!0,Y=!1,E=void 0;try{for(var W,N=this.object.layer.data[Symbol.iterator]();!(I=(W=N.next()).done);I=!0){var H=W.value,k=H[H.length-1];this.collisionTiles.includes(k.index)?X?X.height++:X={x:k.x+1,y:k.y,height:1}:X&&(O.push(X),X=!1)}}catch(t){Y=!0,E=t}finally{try{I||null==N.return||N.return()}finally{if(Y)throw E}}o.push(O);for(var F=0,q=o;F<q.length;F++){var U=q[F];if(U){var z=!0,J=!1,K=void 0;try{for(var Q,V=function(){var s=Q.value,o=s.x*t.object.layer.tileWidth*t.object.scaleX+n.x,a=s.y*t.object.layer.tileHeight*t.object.scaleY+n.y,h=a+t.object.layer.tileHeight*t.object.scaleY*s.height,c=new Phaser.Geom.Line(o,a,o,h);i.push(c),e.filter((function(t){return t.x==o&&t.y==a}))||e.push(new Phaser.Geom.Point(o,y)),e.filter((function(t){return t.x==o&&t.y==h}))||e.push(new Phaser.Geom.Point(o,y));var l=!0,u=!1,g=void 0;try{for(var d,f=r[Symbol.iterator]();!(l=(d=f.next()).done);l=!0){var v=d.value;if(c.x1!=v.x1&&c.x1!=v.x2&&c.x2!=v.x1&&c.x2!=v.x2&&(c.y1!=v.y1&&c.y1!=v.y2&&c.y2!=v.y1&&c.y2!=v.y2)){var b=new Phaser.Geom.Point;Phaser.Geom.Intersects.LineToLine(c,v,b)&&e.push(b)}}}catch(t){u=!0,g=t}finally{try{l||null==f.return||f.return()}finally{if(u)throw g}}},Z=U[Symbol.iterator]();!(z=(Q=Z.next()).done);z=!0)V()}catch(t){J=!0,K=t}finally{try{z||null==Z.return||Z.return()}finally{if(J)throw K}}}}return this._points=e,this._segments=i,this}function o(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return this.collisionTiles=t,this}i.r(e),i.d(e,"getPoints",(function(){return n})),i.d(e,"getSegments",(function(){return s})),i.d(e,"updateMap",(function(){return r})),i.d(e,"setCollisionTiles",(function(){return o}))},function(t,e,i){"use strict";function n(t,e){this._raycaster=e||!1,this.origin=new Phaser.Geom.Point,this._ray=new Phaser.Geom.Line,this.angle=0,this.cone=0,this.rayRange=Phaser.Math.MAX_SAFE_INTEGER,this.detectionRange=0,this.detectionRangeCircle=new Phaser.Geom.Circle,this.collisionRange=Phaser.Math.MAX_SAFE_INTEGER,this.ignoreNotIntersectedRays=!0,this.autoSlice=!1,this.intersections=[],this.slicedIntersections=[],this.config(t)}i.r(e),i.d(e,"Ray",(function(){return n})),n.prototype={config:i(16).config,setRay:i(17).setRay,setOrigin:i(18).setOrigin,setRayRange:i(0).setRayRange,setAngle:i(2).setAngle,setAngleDeg:i(2).setAngleDeg,setCone:i(3).setCone,setConeDeg:i(3).setConeDeg,setDetectionRange:i(0).setDetectionRange,boundsInRange:i(0).boundsInRange,cast:i(19).cast,castCircle:i(20).castCircle,castCone:i(21).castCone,slice:i(22).slice,setCollisionRange:i(0).setCollisionRange,enableArcadePhysics:i(23).enableArcadePhysics,overlap:i(1).overlap,processOverlap:i(1).processOverlap,testOverlap:i(1).testOverlap}},function(t,e,i){"use strict";function n(t){return this.object=t.object,void 0!==t.origin&&this.origin.setTo(t.origin.x,t.origin.y),void 0!==t.angle&&(this.angle=Phaser.Math.Angle.Normalize(t.angle)),void 0!==t.angleDeg&&(this.angle=Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(t.angleDeg))),void 0!==t.cone&&(this.cone=t.cone),void 0!==t.coneDeg&&(this.cone=Phaser.Math.DegToRad(t.coneDeg)),void 0!==t.rayRange&&(this.rayRange=t.rayRange),void 0!==t.collisionRange&&(this.collisionRange=t.collisionRange),void 0!==t.detectionRange&&(this.detectionRange=t.detectionRange),void 0!==t.ignoreNotIntersectedRays&&(this.ignoreNotIntersectedRays=1==t.ignoreNotIntersectedRays),void 0!==t.autoSlice&&(this.autoSlice=1==t.autoSlice),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}i.r(e),i.d(e,"config",(function(){return n}))},function(t,e,i){"use strict";function n(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Phaser.Math.MAX_SAFE_INTEGER;return this.origin.setTo(t,e),this.angle=Phaser.Math.Angle.Normalize(i),this.rayRange=n,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}i.r(e),i.d(e,"setRay",(function(){return n}))},function(t,e,i){"use strict";function n(t,e){return this.origin.setTo(t,e),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),void 0!==this.body&&(this.arcadePhysicsCircle.x=t,this.arcadePhysicsCircle.y=e),this}i.r(e),i.d(e,"setOrigin",(function(){return n}))},function(t,e,i){"use strict";function n(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=this.rayRange;if(this._raycaster&&this._raycaster.boundingBox){var n=[];if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray,this._raycaster.boundingBox.rectangle,n),1===n.length)t=n[0];else if(n.length>1){var s=!0,r=!1,o=void 0;try{for(var a,h=n[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value,l=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,c.x,c.y);l<i&&(i=l,t=c)}}catch(t){r=!0,o=t}finally{try{s||null==h.return||h.return()}finally{if(r)throw o}}}else if(e.target){var u=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.target.x,e.target.y);this.rayRange>u&&(i=u,t=e.target)}}if(!e.objects){if(!this._raycaster)return intersections;e.objects=this._raycaster.mappedObjects}var g=!0,y=!1,d=void 0;try{for(var f,v=e.objects[Symbol.iterator]();!(g=(f=v.next()).done);g=!0){var b=f.value;if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray,b.getBounds())){var p=b.data.get("raycasterMap"),P=!0,m=!1,x=void 0;try{for(var j,w=p.getSegments(this)[Symbol.iterator]();!(P=(j=w.next()).done);P=!0){var G=j.value,R=[];if(e.target){if(Phaser.Geom.Point.Equals(e.target,G.getPointA())||Phaser.Geom.Point.Equals(e.target,G.getPointB()))R=e.target;else if(!Phaser.Geom.Intersects.LineToLine(this._ray,G,R))continue}else if(!Phaser.Geom.Intersects.LineToLine(this._ray,G,R))continue;var L=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,R.x,R.y);L<i&&(i=L,t=R)}}catch(t){m=!0,x=t}finally{try{P||null==w.return||w.return()}finally{if(m)throw x}}if("Arc"===p.type){if(p._points.length>0)continue;if(e.target){var S=p.getPoints(this),M=!1,A=!0,_=!1,T=void 0;try{for(var B,C=S[Symbol.iterator]();!(A=(B=C.next()).done);A=!0){var D=B.value;if(Phaser.Geom.Point.Equals(e.target,D)){var X=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,D.x,D.y);if(X<i){i=X,t=D,M=!0;break}}}}catch(t){_=!0,T=t}finally{try{A||null==C.return||C.return()}finally{if(_)throw T}}if(M)continue}var O=[],I=new Phaser.Geom.Point;I.x=p.object.x-p.object.displayWidth*(p.object.originX-.5),I.y=p.object.y-p.object.displayHeight*(p.object.originY-.5);var Y=p.object.rotation;if(0!==Y){var E=new Phaser.Geom.Line(p.object.x,p.object.y,I.x,I.y);Phaser.Geom.Line.SetToAngle(E,p.object.x,p.object.y,Phaser.Geom.Line.Angle(E)+Y,Phaser.Geom.Line.Length(E));var W=E.getPointB();I.x=W.x,I.y=W.y}var N=new Phaser.Geom.Circle(I.x,I.y,p.object.radius*p.object.scaleX);if(Phaser.Geom.Intersects.GetLineToCircle(this._ray,N,O)){var H=!0,k=!1,F=void 0;try{for(var q,U=O[Symbol.iterator]();!(H=(q=U.next()).done);H=!0){var z=q.value,J=Phaser.Math.Distance.Between(this._ray.x1,this._ray.y1,z.x,z.y);J<i&&(i=J,t=z)}}catch(t){k=!0,F=t}finally{try{H||null==U.return||U.return()}finally{if(k)throw F}}}}}}}catch(t){y=!0,d=t}finally{try{g||null==v.return||v.return()}finally{if(y)throw d}}return t?new Phaser.Geom.Point(t.x,t.y):!this.ignoreNotIntersectedRays&&this._ray.getPointB()}i.r(e),i.d(e,"cast",(function(){return n}))},function(t,e,i){"use strict";function n(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=this.angle,i=[],n=[],s=[],r=[];if(!t.objects){if(!this._raycaster)return i;if(t.objects=this._raycaster.mappedObjects,this._raycaster&&this._raycaster.boundingBox){var o=!0,a=!1,h=void 0;try{for(var c,l=this._raycaster.boundingBox.points[Symbol.iterator]();!(o=(c=l.next()).done);o=!0){var u=c.value;s.push({point:u,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,u.x,u.y)})}}catch(t){a=!0,h=t}finally{try{o||null==l.return||l.return()}finally{if(a)throw h}}}for(var g=0,y=t.objects.length;g<y;g++){var d=t.objects[g];if(this.boundsInRange(d)){r.push(d);var f=d.data.get("raycasterMap");n.push(f);var v=!0,b=!1,p=void 0;try{for(var P,m=f.getPoints(this)[Symbol.iterator]();!(v=(P=m.next()).done);v=!0){var x=P.value;s.push({point:x,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,x.x,x.y)})}}catch(t){b=!0,p=t}finally{try{v||null==m.return||m.return()}finally{if(b)throw p}}for(var j=g+1,w=t.objects.length;j<w;j++){var G=t.objects[j],R=G.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(d.getBounds(),G.getBounds())){var L=!0,S=!1,M=void 0;try{for(var A,_=f.getSegments(this)[Symbol.iterator]();!(L=(A=_.next()).done);L=!0){var T=A.value,B=!0,C=!1,D=void 0;try{for(var X,O=R.getSegments(this)[Symbol.iterator]();!(B=(X=O.next()).done);B=!0){var I=X.value,Y=[];Phaser.Geom.Intersects.LineToLine(T,I,Y)&&s.push({point:new Phaser.Geom.Point(Y.x,Y.y),angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,Y.x,Y.y)})}}catch(t){C=!0,D=t}finally{try{B||null==O.return||O.return()}finally{if(C)throw D}}}}catch(t){S=!0,M=t}finally{try{L||null==_.return||_.return()}finally{if(S)throw M}}}}}}s.sort(function(t,e){return t.angle==e.angle?Phaser.Math.Distance.Between(this.origin.x,this.origin.y,t.point.x,t.point.y)<Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.point.x,e.point.y)?1:-1:t.angle-e.angle}.bind(this));var E=!0,W=!1,N=void 0;try{for(var H,k=s[Symbol.iterator]();!(E=(H=k.next()).done);E=!0){var F=H.value;this.setAngle(F.angle);var q=this.cast({objects:r,target:F.point});if(q){if(Phaser.Geom.Point.Equals(F.point,q)){this.setAngle(F.angle-1e-4);var U=this.cast({objects:r});U&&i.push(U),i.push(q),this.setAngle(F.angle+1e-4);var z=this.cast({objects:r});z&&i.push(z);continue}i.push(q)}}}catch(t){W=!0,N=t}finally{try{E||null==k.return||k.return()}finally{if(W)throw N}}}return this.setAngle(e),this.intersections=i,this.autoSlice&&(this.slicedIntersections=this.slice()),i}i.r(e),i.d(e,"castCircle",(function(){return n}))},function(t,e,i){"use strict";function n(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=this.angle,i=[],n=[],s=[],r=[],o=this.cone,a=0,h=0;if(void 0!==t.cone&&(o=t.cone),void 0!==t.coneDeg&&(o=Phaser.Math.DegToRad(t.coneDeg)),a=this.angle-o/2,h=this.angle+o/2,this.setAngle(a),s.push({point:this._ray.getPointB(),angle:a,angleOffsetDeg:Phaser.Math.RadToDeg(-o/2)}),this.setAngle(h),s.push({point:this._ray.getPointB(),angle:h,angleOffsetDeg:Phaser.Math.RadToDeg(o/2)}),!t.objects){if(!this._raycaster)return i;if(t.objects=this._raycaster.mappedObjects,this._raycaster&&this._raycaster.boundingBox){var c=!0,l=!1,u=void 0;try{for(var g,y=this._raycaster.boundingBox.points[Symbol.iterator]();!(c=(g=y.next()).done);c=!0){var d=g.value,f=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,d.x,d.y),v=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(f),Phaser.Math.RadToDeg(e));Math.abs(v)<Phaser.Math.RadToDeg(o/2)&&s.push({point:d,angle:f,angleOffsetDeg:-v})}}catch(t){l=!0,u=t}finally{try{c||null==y.return||y.return()}finally{if(l)throw u}}}}for(var b=0,p=t.objects.length;b<p;b++){var P=t.objects[b];if(this.boundsInRange(P)){r.push(P);var m=P.data.get("raycasterMap");n.push(m);var x=!0,j=!1,w=void 0;try{for(var G,R=m.getPoints(this)[Symbol.iterator]();!(x=(G=R.next()).done);x=!0){var L=G.value,S=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,L.x,L.y),M=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(S),Phaser.Math.RadToDeg(e));Math.abs(M)<Phaser.Math.RadToDeg(o/2)&&s.push({point:L,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,L.x,L.y),angleOffsetDeg:-M})}}catch(t){j=!0,w=t}finally{try{x||null==R.return||R.return()}finally{if(j)throw w}}for(var A=b+1,_=t.objects.length;A<_;A++){var T=t.objects[A],B=T.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(P.getBounds(),T.getBounds())){var C=!0,D=!1,X=void 0;try{for(var O,I=m.getSegments(this)[Symbol.iterator]();!(C=(O=I.next()).done);C=!0){var Y=O.value,E=!0,W=!1,N=void 0;try{for(var H,k=B.getSegments(this)[Symbol.iterator]();!(E=(H=k.next()).done);E=!0){var F=H.value,q=[];if(Phaser.Geom.Intersects.LineToLine(Y,F,q)){var U=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,q.x,q.y),z=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(U),Phaser.Math.RadToDeg(e));Math.abs(z)<Phaser.Math.RadToDeg(o/2)&&s.push({point:new Phaser.Geom.Point(q.x,q.y),angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,q.x,q.y),angleOffsetDeg:-z})}}}catch(t){W=!0,N=t}finally{try{E||null==k.return||k.return()}finally{if(W)throw N}}}}catch(t){D=!0,X=t}finally{try{C||null==I.return||I.return()}finally{if(D)throw X}}}}}}s.sort(function(t,e){return t.angle==e.angle?Phaser.Math.Distance.Between(this.origin.x,this.origin.y,t.point.x,t.point.y)<Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.point.x,e.point.y)?1:-1:t.angleOffsetDeg-e.angleOffsetDeg}.bind(this));for(var J=0,K=s;J<K.length;J++){var Q=K[J];this.setAngle(Q.angle);var V=this.cast({objects:r,target:Q.point});if(V){if(Phaser.Geom.Point.Equals(Q.point,V)){this.setAngle(Q.angle-1e-4);var Z=this.cast({objects:r});Z&&i.push(Z),i.push(V),this.setAngle(Q.angle+1e-4);var $=this.cast({objects:r});$&&i.push($);continue}i.push(V)}}return this.setAngle(e),this.intersections=i,this.autoSlice&&(this.slicedIntersections=this.slice(i,!1)),i}i.r(e),i.d(e,"castCone",(function(){return n}))},function(t,e,i){"use strict";function n(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.intersections,e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!Array.isArray(t)){if(4!==t.type)return[];t=t.points}if(0===t.length)return[];for(var i=[],n=0,s=t.length-1;n<s;n++)i.push(new Phaser.Geom.Triangle(this.origin.x,this.origin.y,t[n].x,t[n].y,t[n+1].x,t[n+1].y));return e&&i.push(new Phaser.Geom.Triangle(this.origin.x,this.origin.y,t[0].x,t[0].y,t[t.length-1].x,t[t.length-1].y)),i}i.r(e),i.d(e,"slice",(function(){return n}))},function(t,e,i){"use strict";function n(){return void 0!==this.body?this:(this.arcadePhysicsCircle=this._raycaster.scene.add.circle(this.origin.x,this.origin.y,this.collisionRange),this.arcadePhysicsCircle._ray=this,this._raycaster.scene.physics.add.existing(this.arcadePhysicsCircle),this.body=this.arcadePhysicsCircle.body,this.body.setCircle(this.collisionRange).setAllowGravity(!1).setImmovable(!0),this)}i.r(e),i.d(e,"enableArcadePhysics",(function(){return n}))}])}));
//# sourceMappingURL=phaser-raycaster.min.js.map